/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package eastvillage.cj20s

import eastvillage.cj20s.game.*
import eastvillage.cj20s.game.dungeon.Direction
import eastvillage.cj20s.game.dungeon.Dungeon
import eastvillage.cj20s.game.dungeon.MoveOutcome
import net.dv8tion.jda.core.JDABuilder
import net.dv8tion.jda.core.events.message.MessageReceivedEvent
import net.dv8tion.jda.core.hooks.ListenerAdapter
import java.lang.StringBuilder
import kotlin.random.Random

fun main(args: Array<String>) {
    if (args.isEmpty()) {
        println("Needs one argument ('bot-token')")
    } else {
        val jda = JDABuilder(args[0]).build()
        jda.addEventListener(MessageListener())
    }
}

class MessageListener : ListenerAdapter() {

    override fun onMessageReceived(event: MessageReceivedEvent) {
        if (!event.author.isBot) {
            println("Msg received from '${event.author.name}' (${event.author.id}): ${event.message.contentRaw}")
            PlayerManager.registerIfNew(event.author)
            val player = PlayerManager.getOrRegister(event.author)
            if (event.message.contentRaw.startsWith("!")) {
                val response = parseCommand(player, event.message.contentRaw)
                when (response) {
                    is TextResponse -> event.channel.sendMessage(response.msg).queue()
                    is DungeonResponse -> {
                        val encounter = EncounterManager.encounter
                        val encounterDescription = if (encounter != null) "You are currently fighting ${encounter.monster.longname} in a fierce battle!\n${encounter.toStatusString()}" else ""
                        val msg = "${response.msg}\n${DungeonManager.dungeon.asEmotes()}Keys: ${Inventory.keys}, gold: ${Inventory.gold}\n${encounterDescription}"
                        event.channel.sendMessage(msg).queue()
                    }
                    is ErrorResponse -> event.channel.sendMessage("${listOf(
                            "I don't understand.. ?",
                            "That's gibberish!",
                            "Ehm, so I am not the only one here smoking, I see.. ?",
                            "Sorry, what did you mean to say?",
                            "That's not how it works!",
                            "No no no...",
                            "Uhhhhhhhhh",
                            "Oh my. That's not correct",
                            "Sorry. I wasn't listening",
                            "Lol",
                            "Error on line 1",
                            "That does not compile ...",
                            "Are you making fun of me now?"
                    ).random()}\n${response.msg}").queue()
                }
            }
        }
    }
}

fun parseCommand(player: Player, command: String): Response {
    val pieces = command.split(' ')
    val func = pieces[0]
    val args = if (pieces.size > 1) pieces.subList(1, pieces.size) else listOf()
    println(pieces)
    return when (func) {
        "!hello" -> expect(0, args, "!hello") ?: TextResponse("Hello my friend!")
        "!help" -> expect(0, args, "!help") ?: helpResponse()
        "!createcharacter" -> expect(2, args, "!createcharacter <name> (wizard|sorcerer|priest|warlock)")
                ?: createCharacter(player, args[0], args[1])
        "!suicide" -> expect(0, args, "!suicide") ?: suicide(player)
        "!dungeon" -> expect(0, args, "!dungoen")
                ?: DungeonResponse("You are right there. \\*points awkwardly with a claw\\*")
        "!move" -> expect(1, args, "!move (north|south|west|east)") ?: resolveMove(player, args[0])
        "!cast" -> tryCast(player, args)
        "!character" -> expect(0, args, "!character") ?: characterDetails(player)
        else -> NoResponse
    }
}

fun expect(expected: Int, args: List<String>, format: String): ErrorResponse? {
    if (args.size != expected) {
        return ErrorResponse("Wrong number of arguments. The format of the command is:\n$format")
    }
    return null
}

fun helpResponse(): TextResponse {
    return TextResponse("""
        Hello. I am your dungeon master. I will be guiding you and your party through the dungeon!
        Use the following commands to let me know what you want to do:
        !createcharacter <name> (wizard|sorcerer|priest|warlock)
        !character
        !suicide
        !cast <spell> (<character>|enemy)
        !dungeon
        !move (north|south|east|west)
        
        The "<something>" means you must enter something valid. (a|b|c) means you must choose one of a, b, or c. And [a|b|c] means you can optionally choose a, b, or c.
    """.trimIndent())
}

fun createCharacter(player: Player, characterName: String, classStr: String): TextResponse {
    if (player.character == null) {
        if (characterName.length > 12) {
            return TextResponse("That character name is too long. Maybe they have a nickname you can use instead?")
        }
        val pcclass = when (classStr) {
            "wizard" -> PCClass.WIZARD
            "sorcerer" -> PCClass.SORCERER
            "priest" -> PCClass.PRIEST
            "warlock" -> PCClass.WARLOCK
            else -> return TextResponse("Sorry, in this world you can only be a wizard, sorcerer, priest, or warlock. Not '$classStr'. Did you not read the rules!??!")
        }
        player.character = Character(player, characterName, pcclass)
        return TextResponse("Very well. You now have a $pcclass named $characterName. ${listOf(
                "Let the adventure begin!",
                "Can't wait to tell their story!",
                "I already like them!",
                "May they become a great adventurer!",
                "I am sure they are nice!",
                "Interesting character!"
        ).random()}\nSee information about your character anytime using !character.")
    } else {
        val character = player.character!!
        return TextResponse("""
            Wait a second. You already have a character, ${character.realname} the ${character.pcClass}.
            If you want to get rid of him, use !suicide. But keep it clean, okay?
        """.trimIndent())
    }
}

fun suicide(player: Player): TextResponse {
    val character = player.character
    if (character == null) {
        return TextResponse("${listOf(
                "You don't even have a character.",
                "Ha ha, nice try.",
                "Wow. Well..."
        ).random()} First you need to create one with the !createcharacter command.")
    } else {
        player.character = null
        return TextResponse("${listOf(
                "Okay. There's no going back though!",
                "Brutal.",
                "Oof, this is gonna be ugly."
        ).random()}\n${listOf(
                "*The party glance back and finds ${character.realname} lying on the floor behind them. Dead. Shocked they looked around the room, but they cannot see the cause of the ${character.pcClass}'s demise*",
                "*A sudden fear grasps ${character.realname}, and they run out of the room screaming. The party does not have time to react before the ${character.pcClass} is gone forever*",
                "*${character.realname} spontaneously combusts. May them rest in pieces*"
        ).random()}\n\n\\*Sigh\\* Create a new character with the !createcharacter command.")
    }
}

fun resolveMove(player: Player, dirStr: String): Response {
    val dir = when (dirStr) {
        "north" -> Direction.NORTH
        "south" -> Direction.SOUTH
        "west" -> Direction.WEST
        "east" -> Direction.EAST
        else -> return ErrorResponse("You can only move north, south, west, or east!")
    }

    val character = player.character
    if (character == null) {
        return TextResponse("${listOf(
                "I am afraid you can't lead the party without a character.",
                "You don't have a character so you can't do that.",
                "Shut up ${player.name}! You need a character first."
        ).random()}\nCreate a new character with the !createcharacter command.")
    }

    val encounter = EncounterManager.encounter
    if (encounter != null) {
        val monster = encounter.monster
        return TextResponse("${listOf(
                "You try to flee, but the ${monster.race} is too fast and catches up to you.",
                "Sorry, you can't escape this combat. The ${monster.race} is coming for you!",
                "Well. Your party is a bit occupied with a ${monster.race} and can't move.",
                "Uhhhh, okay. Let's do that afterwards.",
                "You run towards the hallway, but the ${monster.race} prevents your escape. You are trapped."
        ).random()}\nYou must defeat the monster by casting spells. Use the !cast command for that.")
    }

    val outcome = DungeonManager.dungeon.move(dir)
    return when (outcome) {
        MoveOutcome.SUCCESS -> DungeonResponse("You move $dir")
        MoveOutcome.FINDS_KEY -> DungeonResponse(listOf(
                "Despite your incompetence, you manage find a key!",
                "You move $dir. As you are about to move on something catches your eye. A golden key is lying the in the dust",
                "An pile of bones lies before you. Creepily you investigate the poor guy's remains - and find a key!",
                "A key lies on the ground. You decide to pick it up as it might be useful"
        ).random())
        MoveOutcome.WALL -> DungeonResponse(listOf(
                "Eh, you can't",
                "You walk $dir and bang your head into the wall ..",
                "A wall blocks your way",
                "There seem to be a wall there"
        ).random())
        MoveOutcome.NEED_KEY -> DungeonResponse(listOf(
                "There's a door and it's locked",
                "You try the door handle, but it's locked",
                "You realize that you don't have the key and facepalms",
                "The door to the $dir does not move"
        ).random())
        MoveOutcome.OPEN_DOOR -> DungeonResponse(listOf(
                "You slide the key into the keyhole ... it fits! The door opens",
                "Carefully you unlock the door and push it open. You stare into another dark hallway",
                "The door creaks as you open it"
        ).random())
        MoveOutcome.ENCOUNTER -> {
            val encounter = EncounterManager.encounter!!
            val monster = encounter.monster
            if (monster.isBoss) {
                TextResponse("${listOf(
                        "The room darkens around you. You feel the heat leaving your body. Before you stands ${monster.longname}. Prepare to fight mortals!",
                        "You shiver as you realize, that you are standing in front of ${monster.longname}.",
                        "A strange sound startles you. You are in the presence of a great evil. Ready your minds, a long battle with ${monster.longname} is about to begin!",
                        "The room smells of death and decay. Piles bones surrounds ${monster.longname} who looks directly at you.",
                        "The adventure is nearing its end. Muster all your strength and hold onto your life as before you is a being of incredible power: ${monster.longname}."
                ).random()}\n${encounter.toStatusString()}")
            } else {
                TextResponse("${listOf(
                        "Before you stand a terrifying ${monster.race}. Prepare to fight!",
                        "In the middle of the room stands a ${monster.race} looking very angry. Roll for initiative!",
                        "A ${monster.race} jumps in front of you! Prepare your spells!",
                        "It's an ambush. A ${monster.race} jumps at you with fury in it's eyes.",
                        "You wander into the room. You hear a click under your feet... You look up and see a ${monster.race} coming at you!",
                        "You walk in on a ${monster.race} trying to mind its own business.",
                        "You hear the distinct sound of a ${monster.race} and get ready to fight.",
                        "The room stinks of ${monster.race}. Unsurprisingly, you see one in the corner as it turns around. It lunges at you!",
                        "Your power will be tested as a ${monster.race} readies itself before you."
                ).random()}\n${encounter.toStatusString()}")
            }
        }
        MoveOutcome.OPEN_CHEST -> {
            val gold = Random.nextInt(10, 50)
            Inventory.gold += gold
            DungeonResponse(listOf(
                    "A beautiful chest lies in the corner. Carefully you open it. You find $gold gold inside!",
                    "You find a big but open treasure chest. It's basically empty, but there's $gold gold pieces lying lonely on the bottom.",
                    "A body lies on the ground. Moveless and cold. You search the body and find $gold gold pieces.",
                    "There are two chests in the room. You open the chest covered in spiderwebs. It's empty and you feel sad. You open the other one expecting it to be empty too. And it is. Dissapointed you pick the $gold gold pieces lying next to the chests."
            ).random())
        }
    }
}

fun tryCast(player: Player, args: List<String>): Response {
    if (args.isEmpty() || args.size > 2) return ErrorResponse("""
    Wrong number of arguments. The format of the command is
    !cast <spell> [<character>|enemy]
    """.trimIndent())

    val character = player.character
    if (character == null) return TextResponse("${listOf(
            "Silly human.",
            "Your spell fizzles .. because there is no one to cast it.",
            "Spells don't appear from thin air ..."
    ).random()}\nYou can't cast spells without a character. Create a character with the !createcharacter command")

    if (character.isDead) return TextResponse("${listOf(
            "The ghost of ${character.realname} the ${character.pcClass} tries to cast a spell - but ghosts cannot cast spells.",
            "Your character is dead. Sorry not sorry.",
            "You can't cast spells when your character is dead.",
            "Well, too late my friend. Your character ${character.realname} is dead."
    ).random()} Create a new character with the !createcharacter command")

    val spell = character.spells.firstOrNull { it.name == args[0] }
            ?: return ErrorResponse("You don't have a spell named ${args[0]}.")

    val encounter = EncounterManager.encounter ?: return ErrorResponse("You can only cast spells while in combat.")

    var target: Targetable? = null
    val outcome = when (spell) {
        is TargetedSpell -> {
            if (args.size == 2) {
                val targetName = args[1]
                if (targetName == "enemy") {
                    spell.perform(character, encounter.monster)
                } else {
                    val allCharacters = PlayerManager.allPlayers.map { it.character }
                    target = allCharacters.firstOrNull { it != null && it.realname == targetName }
                    if (target == null) return ErrorResponse("$targetName is not a valid target. Write the name of either a character or simply 'enemy'")
                    // TODO Target might be dead??
                    spell.perform(character, target)
                }
            } else {
                return ErrorResponse("""
                Wrong number of arguments. The ${spell.name} spell requires a target. Write the name of the target, either a character name or 'enemy':
                !cast <spell> [<character>|enemy]
                """.trimIndent())
            }
        }
        is UntargetedSpell -> {
            if (args.size == 1) {
                spell.perform(character)
            } else {
                return ErrorResponse("Wrong number of arguments. The ${spell.name} spell does not require a target.")
            }
        }
    }

    encounter.frontline.moveToFront(character)

    val onTargetText = if (target != null) " on ${target.longname}" else ""
    val deadText = if (target != null && target.isDead && target !is Monster) "\n\n${listOf(
            "${target.longname.capitalize()} has been eliminated!",
            "Oof. That means ${target.longname} has died!",
            "Here ends the adventure of ${target.longname}. May they rest in piece."
    ).random()}" else ""

    val enemyAttackText = if (!encounter.monster.isDead) {
        "\n${encounter.resolveAttack()}"
    } else {
        ""
    }

    val descriptionOfTheEvents = "You successfully cast ${spell.name}$onTargetText!\n$outcome$enemyAttackText$deadText"

    if (encounter.monster.isDead) {
        return endCombat(descriptionOfTheEvents)
    } else {
        return TextResponse("$descriptionOfTheEvents\n${encounter.toStatusString()}")
    }
}

fun endCombat(descriptionOfTheEvents: String): Response {
    val monster = EncounterManager.encounter!!.monster
    EncounterManager.encounter = null
    return DungeonResponse("$descriptionOfTheEvents\n\n${monster.longname.capitalize()} has been defeated!") // TODO Loot or exp
}

fun characterDetails(player: Player): TextResponse {
    val character = player.character
    if (character == null) {
        return TextResponse("${listOf(
                "I am afraid you don't have a character.",
                "So you want to have a character?",
                "I would love you tell you have your character.. If you had one!",
                "Sure. I will tell you about your character. There's just one problem. You don't have a one."
        ).random()}\nCreate a character with the !createcharacter command.")
    }

    val desc = StringBuilder("""
        **Character of $player**
        Name: ${character.realname}
        Class: ${character.pcClass}
        Health: ${character.health.currentHealth}/${character.health.getMaxHealth()} hp, ${character.health.asEmojis(withText = false)}

        **Spells:**
        
    """.trimIndent())
    for (spell in character.spells) {
        desc.append(spell.name).append(": ").append(spell.desc).append("\n")
    }

    return TextResponse(desc.toString())
}