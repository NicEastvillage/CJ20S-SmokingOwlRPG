/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package eastvillage.cj20s

import eastvillage.cj20s.game.*
import eastvillage.cj20s.game.dungeon.Direction
import eastvillage.cj20s.game.dungeon.Dungeon
import eastvillage.cj20s.game.dungeon.MoveOutcome
import net.dv8tion.jda.core.JDA
import net.dv8tion.jda.core.JDABuilder
import net.dv8tion.jda.core.entities.Game
import net.dv8tion.jda.core.events.message.MessageReceivedEvent
import net.dv8tion.jda.core.hooks.ListenerAdapter
import java.lang.StringBuilder
import kotlin.random.Random

fun main(args: Array<String>) {
    if (args.isEmpty()) {
        println("Needs one argument ('bot-token')")
    } else {
        val jda = JDABuilder(args[0]).build()
        jda.addEventListener(MessageListener())
        jda.presence.game = Game.playing("The Dungeon Master")
    }
}

class MessageListener : ListenerAdapter() {

    override fun onMessageReceived(event: MessageReceivedEvent) {
        if (!event.author.isBot && event.channel.id == "693140081732747275") {
            println("Msg received from ${event.author.name}: ${event.message.contentRaw}")
            PlayerManager.registerIfNew(event.author)
            val player = PlayerManager.getOrRegister(event.author)
            if (event.message.contentRaw.startsWith("!")) {
                val response = parseCommand(player, event.message.contentRaw)
                makeResonse(event, response)
            }
            //event.channel.sendMessage("Hello! I am your dungeon master. I hope you don't mind that I smoke in here. Actually, this is my place, so you can't stop me. Anyway, welcome to the world of Zarkoa. A land far away where magic is very prevalent. Start by creating your character. I will meet you in #general. The rest of your party members have already started. Come on, get moving.").queue()
        }
    }
}

fun makeResonse(event: MessageReceivedEvent, response: Response) {
    when (response) {
        is TextResponse -> event.channel.sendMessage(response.msg).queue()
        is DungeonResponse -> {
            val encounter = EncounterManager.encounter
            val msg = "${response.msg}\n${DungeonManager.dungeon.asEmotes()}Keys: ${Inventory.keys}, gold: ${Inventory.gold}"
            event.channel.sendMessage(msg).queue()
            if (encounter != null) {
                val encounterDescription = "You are currently fighting ${encounter.monster.longname} in a fierce battle!\n${encounter.toStatusString()}"
                event.channel.sendMessage(encounterDescription).queue()
            }
        }
        is ChainedResponse -> {
            makeResonse(event, response.response1)
            makeResonse(event, response.response2)
        }
        is ErrorResponse -> event.channel.sendMessage("${listOf(
                "I don't understand.. ?",
                "That's gibberish!",
                "Ehm, so I am not the only one here smoking, I see.. ?",
                "Sorry, what did you mean to say?",
                "That's not how it works!",
                "No no no...",
                "Uhhhhhhhhh",
                "Oh my. That's not correct",
                "Sorry. I wasn't listening",
                "Lol",
                "Error on line 1",
                "That does not compile ...",
                "Are you making fun of me now?",
                "Not quite right. We all have to learn. Or well, not me of course. I am already infinitely wise.",
                "Heck. Try again mate."
        ).random()}\n${response.msg}").queue()
        is ActionResponse -> response.action(event)
    }

    if (DungeonManager.dungeon.isComplete()) {
        DungeonManager.beginNewDungeon()
        event.channel.sendMessage("""
            Wow, well done, humans! Maybe you are not that bad after all.
            *Dirty, sweaty, a bit wounded, but proud the party exits the dungeon. They have a smile on their chin even though they lost a few comrades on the way. A nice tavern and a round of beer is ahead. All night the party celebrates in the local tavern telling stories from their adventures and describes in detail how the just barely escaped.
            That was a good day.*
            Bla bla bla. Let's skip forward to the next dungeon...
            *Ahead lies the ruins of the Mesildra. An underground fort long forgotten. The stench is horrible and the darkness is pitch black. The torch light only reaches about 5-6 meters and then ... nothingness. Carefully the party steps into the dungeon.*
            What would you like to do?
        """.trimIndent()).queue()
        Inventory.keys = 0
        val msg = "${DungeonManager.dungeon.asEmotes()}Keys: ${Inventory.keys}, gold: ${Inventory.gold}"
        event.channel.sendMessage(msg).queue()
    }
}

fun parseCommand(player: Player, command: String): Response {
    val pieces = command.split(' ')
    val func = pieces[0]
    val args = if (pieces.size > 1) pieces.subList(1, pieces.size) else listOf()
    println(pieces)
    return when (func) {
        "!hello" -> expect(0, args, "!hello") ?: TextResponse("Hello my friend!")
        "!help" -> expect(0, args, "!help") ?: helpResponse()
        "!createcharacter" -> expect(2, args, "!createcharacter <name> (wizard|sorcerer|priest|warlock)")
                ?: createCharacter(player, args[0], args[1])
        "!suicide" -> expect(0, args, "!suicide") ?: suicide(player)
        "!dungeon" -> expect(0, args, "!dungoen")
                ?: DungeonResponse("You are right there. \\*points awkwardly with a claw\\*")
        "!move" -> expect(1, args, "!move (north|south|west|east)") ?: resolveMove(player, args[0])
        "!cast" -> tryCast(player, args)
        "!character" -> expect(0, args, "!character") ?: characterDetails(player)
        else -> ErrorResponse("I do not know that command. Use !help to see possible commands.")
    }
}

fun expect(expected: Int, args: List<String>, format: String): ErrorResponse? {
    if (args.size != expected) {
        return ErrorResponse("Wrong number of arguments. The format of the command is:\n`$format`")
    }
    return null
}

fun helpResponse(): TextResponse {
    return TextResponse("""
        Hello. I am your dungeon master. I will be guiding you and your party through the dungeon!
        Use the following commands to let me know what you want to do:
        ```
        !createcharacter <name> (wizard|sorcerer|priest|warlock)    # Create a new character
        !character                                                  # See your spells and other info about your character
        !suicide                                                    # Get rid of your character
        !cast <spell> [<character>]                                 # Cast a spell (only during combat)
        !dungeon                                                    # See status of the dungeon or combat
        !move (north|south|east|west)                               # Move the party
        ```
        The "<something>" means you must enter something valid. (a|b|c) means you must choose one of a, b, or c. And [a|b|c] means you can optionally choose a, b, or c.
    """.trimIndent())
}

fun createCharacter(player: Player, characterName: String, classStr: String): Response {
    if (player.character == null) {
        if (characterName.length > 12) {
            return TextResponse("That character name is too long. Maybe they have a nickname you can use instead?")
        }
        if (characterName.contains('@')) {
            return TextResponse("Nice try. I had some bug testers check the bot. They did exactly that. Try something without '@', okay :P")
        }
        val pcclass = when (classStr) {
            "wizard" -> PCClass.WIZARD
            "sorcerer" -> PCClass.SORCERER
            "priest" -> PCClass.PRIEST
            "warlock" -> PCClass.WARLOCK
            else -> return TextResponse("Sorry, in this world you can only be a wizard, sorcerer, priest, or warlock. Not '$classStr'. Did you not read the rules!??!")
        }
        player.character = Character(player, characterName, pcclass)
        return ChainedResponse(
                TextResponse("Very well. You now have a $pcclass named $characterName. ${listOf(
                    "Let the adventure begin!",
                    "Can't wait to tell their story!",
                    "I already like them!",
                    "May they become a great adventurer!",
                    "I am sure they are nice!",
                    "Interesting character!"
                ).random()}\nSee information about your character anytime using !character."),
                ActionResponse { event ->
                    event.guild.controller.removeRolesFromMember(event.member,
                            event.guild.getRoleById(PCClass.WIZARD.toId()),
                            event.guild.getRoleById(PCClass.WARLOCK.toId()),
                            event.guild.getRoleById(PCClass.PRIEST.toId()),
                            event.guild.getRoleById(PCClass.SORCERER.toId())
                    ).queue()
                    println("Assigning role")
                    event.guild.controller.addSingleRoleToMember(event.member, event.guild.getRoleById(pcclass.toId())).queue()
                }
        )
    } else {
        val character = player.character!!
        return TextResponse("""
            Wait a second. You already have a character, ${character.realname} the ${character.pcClass}.
            If you want to get rid of him, use `!suicide`. But keep it clean, okay?
        """.trimIndent())
    }
}

fun suicide(player: Player): TextResponse {
    val character = player.character
    if (character == null) {
        return TextResponse("${listOf(
                "You don't even have a character.",
                "Ha ha, nice try.",
                "Wow. Well..."
        ).random()} First you need to create one with the `!createcharacter` command.")
    } else {
        player.character = null
        return TextResponse("${listOf(
                "Okay. There's no going back though!",
                "Brutal.",
                "Oof, this is gonna be ugly."
        ).random()}\n${listOf(
                "*The party glance back and finds ${character.realname} lying on the floor behind them. Dead. Shocked they looked around the room, but they cannot see the cause of the ${character.pcClass}'s demise*",
                "*A sudden fear grasps ${character.realname}, and they run out of the room screaming. The party does not have time to react before the ${character.pcClass} is gone forever*",
                "*${character.realname} spontaneously combusts. May them rest in pieces*"
        ).random()}\n\n\\*Sigh\\* Create a new character with the `!createcharacter` command.")
    }
}

fun resolveMove(player: Player, dirStr: String): Response {
    val dir = when (dirStr) {
        "north", "up" -> Direction.NORTH
        "south", "down" -> Direction.SOUTH
        "west", "left" -> Direction.WEST
        "east", "right" -> Direction.EAST
        else -> return ErrorResponse("You can only move north, south, west, or east!")
    }

    val character = player.character
    if (character == null) {
        return TextResponse("${listOf(
                "I am afraid you can't lead the party without a character.",
                "You don't have a character so you can't do that.",
                "Shut up ${player.name}! You need a character first."
        ).random()}\nCreate a new character with the `!createcharacter` command.")
    }

    val encounter = EncounterManager.encounter
    if (encounter != null) {
        val monster = encounter.monster
        return TextResponse("${listOf(
                "You try to flee, but the ${monster.race} is too fast and catches up to you.",
                "Sorry, you can't escape this combat. The ${monster.race} is coming for you!",
                "Well. Your party is a bit occupied with a ${monster.race} and can't move.",
                "Uhhhh, okay. Let's do that afterwards.",
                "You run towards the hallway, but the ${monster.race} prevents your escape. You are trapped."
        ).random()}\nYou must defeat the monster by casting spells. Use the `!cast` command for that.")
    }

    val outcome = DungeonManager.dungeon.move(dir)
    return when (outcome) {
        MoveOutcome.SUCCESS -> DungeonResponse("You move $dir")
        MoveOutcome.FINDS_KEY -> DungeonResponse(listOf(
                "Despite your incompetence, you manage find a key!",
                "You move $dir. As you are about to move on something catches your eye. A golden key is lying the in the dust",
                "An pile of bones lies before you. Creepily you investigate the poor guy's remains - and find a key!",
                "A key lies on the ground. You decide to pick it up as it might be useful"
        ).random())
        MoveOutcome.WALL -> DungeonResponse(listOf(
                "Eh, you can't",
                "You walk $dir and bang your head into the wall ..",
                "A wall blocks your way",
                "There seem to be a wall there"
        ).random())
        MoveOutcome.NEED_KEY -> DungeonResponse(listOf(
                "There's a door and it's locked",
                "You try the door handle, but it's locked",
                "You realize that you don't have the key and facepalms",
                "The door to the $dir does not move"
        ).random())
        MoveOutcome.OPEN_DOOR -> DungeonResponse(listOf(
                "You slide the key into the keyhole ... it fits! The door opens",
                "Carefully you unlock the door and push it open. You stare into another dark hallway",
                "The door creaks as you open it"
        ).random())
        MoveOutcome.ENCOUNTER -> {
            val encounter = EncounterManager.encounter!!
            val monster = encounter.monster
            if (monster.isBoss) {
                TextResponse("${listOf(
                        "The room darkens around you. You feel the heat leaving your body. Before you stands ${monster.longname}. Prepare to fight mortals!",
                        "You shiver as you realize, that you are standing in front of ${monster.longname}.",
                        "A strange sound startles you. You are in the presence of a great evil. Ready your minds, a long battle with ${monster.longname} is about to begin!",
                        "The room smells of death and decay. Piles bones surrounds ${monster.longname} who looks directly at you.",
                        "The adventure is nearing its end. Muster all your strength and hold onto your life as before you is a being of incredible power: ${monster.longname}."
                ).random()}\n${encounter.toStatusString()}")
            } else {
                TextResponse("${listOf(
                        "Before you stand a terrifying ${monster.race}. Prepare to fight!",
                        "In the middle of the room stands a ${monster.race} looking very angry. Roll for initiative!",
                        "A ${monster.race} jumps in front of you! Prepare your spells!",
                        "It's an ambush. A ${monster.race} jumps at you with fury in it's eyes.",
                        "You wander into the room. You hear a click under your feet... You look up and see a ${monster.race} coming at you!",
                        "You walk in on a ${monster.race} trying to mind its own business.",
                        "You hear the distinct sound of a ${monster.race} and get ready to fight.",
                        "The room stinks of ${monster.race}. Unsurprisingly, you see one in the corner as it turns around. It lunges at you!",
                        "Your power will be tested as a ${monster.race} readies itself before you."
                ).random()}\n${encounter.toStatusString()}")
            }
        }
        MoveOutcome.OPEN_CHEST -> {
            val gold = Random.nextInt(10, 50)
            Inventory.gold += gold
            DungeonResponse(listOf(
                    "A beautiful chest lies in the corner. Carefully you open it. You find $gold gold inside!",
                    "You find a big but open treasure chest. It's basically empty, but there's $gold gold pieces lying lonely on the bottom.",
                    "A body lies on the ground. Motionless and cold. You search the body and find $gold gold pieces.",
                    "There are two chests in the room. You open the chest covered in spiderwebs. It's empty and you feel sad. You open the other one expecting it to be empty too. And it is. Dissapointed you pick the $gold gold pieces lying next to the chests."
            ).random())
        }
    }
}

fun tryCast(player: Player, args: List<String>): Response {
    if (args.isEmpty() || args.size > 2) return ErrorResponse("""
    Wrong number of arguments. The format of the command is
    `!cast <spell> [<character>]`
    By default I assume you cast the spell on the enemy. But you can write a character's name if you wish the target a player character with your spell.
    """.trimIndent())

    val character = player.character
    if (character == null) return TextResponse("${listOf(
            "Silly human.",
            "Your spell fizzles .. because there is no one to cast it.",
            "Spells don't appear from thin air ..."
    ).random()}\nYou can't cast spells without a character. Create a character with the `!createcharacter` command")

    if (character.isDead) return TextResponse("${listOf(
            "The ghost of ${character.realname} the ${character.pcClass} tries to cast a spell - but ghosts cannot cast spells.",
            "Your character is dead. Sorry not sorry.",
            "You can't cast spells when your character is dead.",
            "Well, too late my friend. Your character ${character.realname} is dead."
    ).random()} Create a new character with the `!createcharacter` command")

    val spell = character.spells.firstOrNull { it.name == args[0] }
            ?: return ErrorResponse("You don't have a spell named ${args[0]}. Use `!character` to see your spells and other info about your character.")

    val encounter = EncounterManager.encounter ?: return ErrorResponse(listOf(
            "You can only cast spells while in combat. Okay?",
            "Nope. Spells can only be cast during combat.",
            "I like the enthusiasm. But spells can only be cast during combat.",
            "Wow there, wait a minute. You can only cast spells while in combat."
    ).random())

    var target: Targetable? = null
    val outcome = when (spell) {
        is TargetedSpell -> {
            target = if (args.size == 2) {
                val targetName = args[1]
                val allCharacters = PlayerManager.allPlayers.map { it.character }
                val characterTarget = allCharacters.firstOrNull { it != null && it.realname == targetName }
                if (characterTarget == null) return ErrorResponse("$targetName is not a valid target. Write the name of a character - or nothing if you want to target the enemy.")
                characterTarget
            } else {
                encounter.monster
            }
            // TODO Target might be dead??
            spell.perform(character, target)
        }
        is UntargetedSpell -> {
            if (args.size == 1) {
                spell.perform(character)
            } else {
                return ErrorResponse("Wrong number of arguments. The ${spell.name} spell does not require a target.")
            }
        }
    }

    encounter.frontline.moveToFront(character)

    val onTargetText = if (target != null) " on ${target.longname}" else ""
    val deadText = if (target != null && target.isDead && target !is Monster) "\n\n${listOf(
            "${target.longname.capitalize()} has been eliminated!",
            "Oof. That means ${target.longname} has died!",
            "Here ends the adventure of ${target.longname}. May they rest in piece."
    ).random()}" else ""

    val enemyAttackText = if (!encounter.monster.isDead) {
        "\n${encounter.resolveAttack()}"
    } else {
        ""
    }

    val descriptionOfTheEvents = "You successfully cast ${spell.name}$onTargetText!\n$outcome$enemyAttackText$deadText"

    if (encounter.monster.isDead) {
        return endCombat(descriptionOfTheEvents)
    } else {
        return TextResponse("$descriptionOfTheEvents\n${encounter.toStatusString()}")
    }
}

fun endCombat(descriptionOfTheEvents: String): Response {
    val monster = EncounterManager.encounter!!.monster
    EncounterManager.encounter = null
    return DungeonResponse("$descriptionOfTheEvents\n\n${monster.longname.capitalize()} has been defeated!\n") // TODO Loot or exp
}

fun characterDetails(player: Player): TextResponse {
    val character = player.character
    if (character == null) {
        return TextResponse("${listOf(
                "I am afraid you don't have a character.",
                "So you want to have a character?",
                "I would love you tell you have your character.. If you had one!",
                "Sure. I will tell you about your character. There's just one problem. You don't have a one."
        ).random()}\nCreate a character with the `!createcharacter` command.")
    }

    val desc = StringBuilder("""
        **Character of $player**
        Name: ${character.realname}
        Class: ${character.pcClass}
        Health: ${character.health.currentHealth}/${character.health.getMaxHealth()} hp, ${character.health.asEmojis(withText = false)}

        **Spells:**
        
    """.trimIndent())
    for (spell in character.spells) {
        desc.append(spell.name).append(": ").append(spell.desc).append("\n")
    }

    return TextResponse(desc.toString())
}